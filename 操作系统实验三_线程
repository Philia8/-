实验目的：
  1、理解线程及线程在调度执行和内存空间等方面的特点，并掌握线程和进程的区别
  2、掌握POSIX规范中pthread_create()函数的功能和使用方法

实验前准备：
  1、了解线程的创建和相关系统调用
    int pthread_create(pthread_t *tidp,const pthread_attr_t *attr,(void *)(*start_rtn)(void *),void *arg)
      (1)头文件：#include <pthread.h>
      (2)参数含义：
        第一个参数为指向线程标识符(tid)的指针，type ： pthread_t*
        第二个参数用来设置线程属性
        第三个参数是线程运行函数的起始地址，也就是线程创建成功后调用函数的起始地址，type ： (void*)(*)(void*)
        第四个参数是运行函数的参数，type ： void *
      (3)返回值说明：
         返回0 ：线程创建成功
         返回出错编号 ：线程创建失败
      (4)函数的作用：创建线程（确定调用该线程函数的入口点），在线程创建以后，就开始运行相关的线程函数
      (5)函数调用示例：
      (6)编译链接参数 ： -lpthread （写在最后）
实验源代码：

1)实验结果猜想：最多创建3个线程，每次回车后输出五个数：
    (1)counter[i]的值（三个），即每个线程对应的counter值，猜想该值表示每个线程的运行thread_worker()函数的次数
    (2)main_counter：共享变量;
    (3)三个线程的counter总和：sum
不相等，系统的调用是没有规律的，故每个进程的运行次数不相同。
         我认为相等，因为在thread_worker()函数中，每调用一次该函数，指定线程的counter值+1，main_counter值+1
 2）最后的结果如你所料吗？有什么特点？对原因进行分析。
      答：前三个数不相同，main_counter 值总小于 sum的值。
          分析：
            main_counter是一个共享变量，在主线程和其他线程运行时都会对该变量进行改变，但是如果在执行线程1时，将main_counter自增，但是未赋值给main_counter变量，此时该变量值缺少1，所以多个线程的多次运行，使得main_counter的值总是少于sum的值
            
    3）thread_worker()的CPU占用率是多少？为什么会这样？
      答：185。该进程在占用CPU的大量资源，因为thread_wroker()函数中的for循环是死循环，必须主动结束进程，否则将一直运行
    4）thread_worker()内是死循环，它是怎样退出的？你认为这样退出好吗？
      答：当用户输入'q'时强制退出进程，则结束所有线程。
        不好。

实验结果：
  1、实验结果猜想：最多创建3个线程，每次回车后输出五个数：
    1)counter[i]的值（三个），即每个线程对应的counter值，猜想该值表示每个线程的运行thread_worker()函数的次数
    2)main_counter：共享变量;
    3)三个线程的counter总和：sum
  2、实验后问题回答：
    1）你最初认为前三列数会相等吗？最后一列斜杠两边的数字是相等，还是大于或小于的关系？
      答：不相等，系统的调用是没有规律的，故每个进程的运行次数不相同。
         我认为相等，因为在thread_worker()函数中，每调用一次该函数，指定线程的counter值+1，main_counter值+1
    2）最后的结果如你所料吗？有什么特点？对原因进行分析。
      答：前三个数不相同，main_counter 值始终小于 sum的值。
          分析：
           main_counter是一个共享变量，在主线程和其他线程运行时都会对该变量进行改变，但是如果在执行线程1时，将main_counter自增，但是未赋值给main_counter变量，此时该变量值缺少1，所以多个线程的多次运行，使得main_counter的值总是少于sum的值
             
    3）thread_worker()的CPU占用率是多少？为什么会这样？
      答：195。该进程在占用CPU的大量资源，因为thread_wroker()函数中的for循环是死循环，必须主动结束进程，否则将一直运行
    4）thread_worker()内是死循环，它是怎样退出的？你认为这样退出好吗？
      答：当用户输入'q'时强制退出进程，则结束所有线程。
        不好。
        如果输入q，所有线程都结束。线程终止的两种方式是：执行return或pthread_exit()。
       执行return：在主线程中，如果main函数返回或调用了exit函数退出主线程，则整个进程中的所有线程也将终止，因此在主线程中不能过早的从main函数返回，可调用pthread_join()函数同步。
       执行pthread_exit()：另一种情况是如果主线程调用pthread_exit()函数，则仅仅是主线程消亡，进程不会结束，进程内的其他线程也不会终止，直到所有线程结束，进程才会结束。
